{
  "version": 3,
  "sources": ["../../lib/base.ts"],
  "sourcesContent": ["/**\n * Chrome reference error while running `processTailwindFeatures` in tailwindcss.\n *  To avoid this, we need to check if the globalThis.chrome is available and add fallback logic.\n */\nconst chrome = globalThis.chrome;\n\n/**\n * Storage area type for persisting and exchanging data.\n * @see https://developer.chrome.com/docs/extensions/reference/storage/#overview\n */\nexport enum StorageType {\n  /**\n   * Persist data locally against browser restarts. Will be deleted by uninstalling the extension.\n   * @default\n   */\n  Local = 'local',\n  /**\n   * Uploads data to the users account in the cloud and syncs to the users browsers on other devices. Limits apply.\n   */\n  Sync = 'sync',\n  /**\n   * Requires an [enterprise policy](https://www.chromium.org/administrators/configuring-policy-for-extensions) with a\n   * json schema for company wide config.\n   */\n  Managed = 'managed',\n  /**\n   * Only persist data until the browser is closed. Recommended for service workers which can shutdown anytime and\n   * therefore need to restore their state. Set {@link SessionAccessLevel} for permitting content scripts access.\n   * @implements Chromes [Session Storage](https://developer.chrome.com/docs/extensions/reference/storage/#property-session)\n   */\n  Session = 'session',\n}\n\n/**\n * Global access level requirement for the {@link StorageType.Session} Storage Area.\n * @implements Chromes [Session Access Level](https://developer.chrome.com/docs/extensions/reference/storage/#method-StorageArea-setAccessLevel)\n */\nexport enum SessionAccessLevel {\n  /**\n   * Storage can only be accessed by Extension pages (not Content scripts).\n   * @default\n   */\n  ExtensionPagesOnly = 'TRUSTED_CONTEXTS',\n  /**\n   * Storage can be accessed by both Extension pages and Content scripts.\n   */\n  ExtensionPagesAndContentScripts = 'TRUSTED_AND_UNTRUSTED_CONTEXTS',\n}\n\ntype ValueOrUpdate<D> = D | ((prev: D) => Promise<D> | D);\n\nexport type BaseStorage<D> = {\n  get: () => Promise<D>;\n  set: (value: ValueOrUpdate<D>) => Promise<void>;\n  getSnapshot: () => D | null;\n  subscribe: (listener: () => void) => () => void;\n};\n\ntype StorageConfig<D = string> = {\n  /**\n   * Assign the {@link StorageType} to use.\n   * @default Local\n   */\n  storageType?: StorageType;\n  /**\n   * Only for {@link StorageType.Session}: Grant Content scripts access to storage area?\n   * @default false\n   */\n  sessionAccessForContentScripts?: boolean;\n  /**\n   * Keeps state live in sync between all instances of the extension. Like between popup, side panel and content scripts.\n   * To allow chrome background scripts to stay in sync as well, use {@link StorageType.Session} storage area with\n   * {@link StorageConfig.sessionAccessForContentScripts} potentially also set to true.\n   * @see https://stackoverflow.com/a/75637138/2763239\n   * @default false\n   */\n  liveUpdate?: boolean;\n  /**\n   * An optional props for converting values from storage and into it.\n   * @default undefined\n   */\n  serialization?: {\n    /**\n     * convert non-native values to string to be saved in storage\n     */\n    serialize: (value: D) => string;\n    /**\n     * convert string value from storage to non-native values\n     */\n    deserialize: (text: string) => D;\n  };\n};\n\n/**\n * Sets or updates an arbitrary cache with a new value or the result of an update function.\n */\nasync function updateCache<D>(valueOrUpdate: ValueOrUpdate<D>, cache: D | null): Promise<D> {\n  // Type guard to check if our value or update is a function\n  function isFunction<D>(value: ValueOrUpdate<D>): value is (prev: D) => D | Promise<D> {\n    return typeof value === 'function';\n  }\n\n  // Type guard to check in case of a function, if its a Promise\n  function returnsPromise<D>(func: (prev: D) => D | Promise<D>): func is (prev: D) => Promise<D> {\n    // Use ReturnType to infer the return type of the function and check if it's a Promise\n    return (func as (prev: D) => Promise<D>) instanceof Promise;\n  }\n\n  if (isFunction(valueOrUpdate)) {\n    // Check if the function returns a Promise\n    if (returnsPromise(valueOrUpdate)) {\n      return await valueOrUpdate(cache as D);\n    } else {\n      return valueOrUpdate(cache as D);\n    }\n  } else {\n    return valueOrUpdate;\n  }\n}\n\n/**\n * If one session storage needs access from content scripts, we need to enable it globally.\n * @default false\n */\nlet globalSessionAccessLevelFlag: StorageConfig['sessionAccessForContentScripts'] = false;\n\n/**\n * Checks if the storage permission is granted in the manifest.json.\n */\nfunction checkStoragePermission(storageType: StorageType): void {\n  if (!chrome) {\n    return;\n  }\n  if (chrome.storage[storageType] === undefined) {\n    throw new Error(`Check your storage permission in manifest.json: ${storageType} is not defined`);\n  }\n}\n\n/**\n * Creates a storage area for persisting and exchanging data.\n */\nexport function createStorage<D = string>(key: string, fallback: D, config?: StorageConfig<D>): BaseStorage<D> {\n  let cache: D | null = null;\n  let listeners: Array<() => void> = [];\n  const storageType = config?.storageType ?? StorageType.Local;\n  const liveUpdate = config?.liveUpdate ?? false;\n  const serialize = config?.serialization?.serialize ?? ((v: D) => v);\n  const deserialize = config?.serialization?.deserialize ?? (v => v as D);\n\n  // Set global session storage access level for StoryType.Session, only when not already done but needed.\n  if (\n    globalSessionAccessLevelFlag === false &&\n    storageType === StorageType.Session &&\n    config?.sessionAccessForContentScripts === true\n  ) {\n    checkStoragePermission(storageType);\n    chrome?.storage[storageType]\n      .setAccessLevel({\n        accessLevel: SessionAccessLevel.ExtensionPagesAndContentScripts,\n      })\n      .catch(error => {\n        console.warn(error);\n        console.warn('Please call setAccessLevel into different context, like a background script.');\n      });\n    globalSessionAccessLevelFlag = true;\n  }\n\n  // Register life cycle methods\n  const _getDataFromStorage = async (): Promise<D> => {\n    checkStoragePermission(storageType);\n    const value = await chrome?.storage[storageType].get([key]);\n    if (!value) {\n      return fallback;\n    }\n    return deserialize(value[key]) ?? fallback;\n  };\n\n  const _emitChange = () => {\n    listeners.forEach(listener => listener());\n  };\n\n  const set = async (valueOrUpdate: ValueOrUpdate<D>) => {\n    cache = await updateCache(valueOrUpdate, cache);\n\n    await chrome?.storage[storageType].set({ [key]: serialize(cache) });\n    _emitChange();\n  };\n\n  const subscribe = (listener: () => void) => {\n    listeners = [...listeners, listener];\n    return () => {\n      listeners = listeners.filter(l => l !== listener);\n    };\n  };\n\n  const getSnapshot = () => {\n    return cache;\n  };\n\n  _getDataFromStorage().then(data => {\n    cache = data;\n    _emitChange();\n  });\n\n  // Listener for live updates from the browser\n  async function _updateFromStorageOnChanged(changes: { [key: string]: chrome.storage.StorageChange }) {\n    // Check if the key we are listening for is in the changes object\n    if (changes[key] === undefined) return;\n\n    const valueOrUpdate: ValueOrUpdate<D> = deserialize(changes[key].newValue);\n\n    if (cache === valueOrUpdate) return;\n\n    cache = await updateCache(valueOrUpdate, cache);\n\n    _emitChange();\n  }\n\n  // Register listener for live updates for our storage area\n  if (liveUpdate) {\n    chrome?.storage[storageType].onChanged.addListener(_updateFromStorageOnChanged);\n  }\n\n  return {\n    get: _getDataFromStorage,\n    set,\n    getSnapshot,\n    subscribe,\n  };\n}\n"],
  "mappings": "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",
  "names": ["StorageType", "SessionAccessLevel", "_a"]
}
